#labels Featured,Phase-Design,Phase-Implementation
Target readers 
Keywords 
JAVA, Spring, architecture, Flex, Cairngorm, Framework,  Hibernate, Integration, Common Issues while integration, User Session, AOP, Performance Tuning, Clob.
 
Introduction
	 Integrating flex with spring, though may seem easy at first look might involve number of challenges that will be discussed in due course of time. This document mainly deals with Integration and mistakes that should be avoided in early stages of project to avoid rework. Each and every problem to be discussed will be addressed and a solution will be given, before moving to the subsequent sections.

Flex, Spring and Hibernate Integration:
	Spring is server-side architecture for the java platform. This document uses the following services provided by Spring framework
•	Inversion of control (IOC)
•	Aspect oriented programming (AOP)
Server side code will have the following
	Domain objects(Java Beans) that will be persisted and retrieved.

	Corresponding mapped .hbm.xml (Hibernate mapping xml) files that specifies which domain object is mapped with which table in DB and its associated data members with data fields. These files will be placed in classpath resource folder and can  be invoked as property from dispatcher servlet using class org.springframework.orm.hibernate3.LocalSessionFactoryBean bean tag.
	Service, Helper and Dao layer to expose java methods (services) to flex via Blaze DS, perform business validations and logic, persist and retrieve domain objects respectively. These layers are comprised of .java classes. At times, Dao layer may extend HibernateDaoSupport which is a template class that will have methods to get session injected from dao-config.xml and provide methods to interact with database.

	There will be a dispatcher-servlet.xml that will be invoked on initial application start up mentioned as context-param in web.xml and will be placed in classpath. This dispatcher-servlet.xml may contain the connection string directly or may have a reference to data source.
The dispatcher-servlet.xml can also be layered in order to maintain uniformity with Service, Helper and Dao layers. The .java classes of respective layers are declared and instantiated (singletons) in these layered dispatcher-servlet.xml (service, helper, dao-config.xmls) appropriately by using <bean> </bean> tag.

Common Mistake #1- Avoid Spring circular references of Bean.
Consider below example

e.g.
Say Class A refers to Class B and Class B in turn refers to Class A.
This should be avoided.
<bean id="ClassA" class="packagePath.A">
<property name="classB" ref="ClassB" />
</bean>     
<bean id="ClassB" class="packagePath.B">
<property name="classA" ref="ClassA" />
</bean>
	A FlexServices-config.xml that contains

<services>
<default-channels>
	<channel ref="my-streaming-amf" />
		<channel ref="my-amf" />
</default-channels>
</services>
<channels>
<channel-definition id="my-amf" class="mx.messaging.channels.AMFChannel">

Common Mistake #2- When you move from http to https normal AMFChannel will stop working and hence SecureAMFEndpoint must be used.
<endpoint url="https://{server.name}:{server.port}/{context.root}/messagebroker/amf" class="flex.messaging.endpoints.SecureAMFEndpoint"/>
</channel-definition>
<channel-definition id="my-streaming-amf" class="mx.messaging.channels.StreamingAMFChannel"> 

<endpoint url="http://{server.name}:{server.port}/{context.root}/messagebroker/streamingamf” class="flex.messaging.endpoints.StreamingAMFEndpoint"/> 

The url contains the link to which clients will make requests and wait for response. StreamingAMFChannel is a class that supports remote method call.

	This FlexServices-Config.xml discussed above will be invoked from flex-servlet.xml which contains 

<flex:message-broker services-config-path="/WEB-INF/<#your package Path>/FlexServices-config.xml">
<flex:remoting-service default-channels="my-amf"/> <flex:message-service default-channels="my-amf"/>
</flex:message-broker>

<!--The services provided by Blaze DS that are used must be mentioned in this xml-->

<flex:remoting-destination ref="<replace with your service layer bean id mentioned in your service-config.xml " />

Use of <flex:remoting-destination> implies  those methods available in referred service bean, will be exposed for remote method invocation(RPC). 
At Flex end:
	All the remote objects will be included in the ServiceLocator under <cairngorm:ServiceLocator tag and the service to be hit will be mentioned in the destination property of the RemoteObject tag. Cairngorm is one of the flex side architecture.
<mx:RemoteObject id="remoteObj" destination="<Service layer bean id that is exposed at server end>" requestTimeout="1000" showBusyCursor="true" channelSet="{myChannelSet}">  
</mx:RemoteObject>
<mx:AMFChannel id="myamf" uri=="http://{server.name}:{server.port}/{context.root}/messagebroker/amf" requestTimeout="1000" />
<mx:ChannelSet id="myChannelSet" channels="{[myamf]}" />
	To call a exposed method of server’s service layer, Use 

private var _service : Object;
_service=ServiceLocator.getInstance().
getRemoteObject("remoteObj");
_service.<#public method you wish to call>

Here the “remoteObj” will be the id of a Remote object.
	The result can be used to populate a form or a data grid and the method that gets called can have similar objects like java domain object mapped to action script (.as) files using [RemoteClass] and [Binding] property.

Common Mistake #3- User session should be maintained to avoid unauthorized access(if different role users  access same method) and class cast exception (if different role users  access same method).
User Session Maintenance:
	User session can be maintained in Spring by specifying scope attribute within bean tag of dispatcher-servlet.xml. <aop:scoped-proxy/> should be added to bean that uses AOP’s scope property.
<bean id="ClassA" class="packagePath.A" scope="session">
<aop:scoped-proxy/>
</bean>

It will be included in package spring-aop.jar that should be included in name space of dispatcher-servlet.xml in order for that tag to be made available.
Creating a Hibernate mapping file:
	A hbm file, in its basic form will have a class tag that will have information about which domain object will be mapped to which table in database.

<class name="<Domain object Path>.<Domain Object>" table="<table name>">

It will have an Id tag, which is used to represent the primary key variable of that domain object.
<id column="<primary key column name of associated table>" name="<variable name>"
<generator class="native">
<param name="sequence"><your sequence name></param>
Common Mistake #4- Despite Hibernate provides number of built in generator classes, Incrementor has a limitation which will lead to batchUpdateError generating same primary key more than once. Hence it is safer to use native oracle sequence.
CLOB:
	Clob is a data type that can store more than 4000 characters. Hibernate demands a special way of handling clob objects.
	How To Handle Clob in JAVA :
While retrieving Clob, Hibernate retrieves it as plain clob object .Say your clob variable that you got from Database is storedClob. To display it as String in Flex it should be converted back to String. It can be done as shown below
long length = storedClob.length();
int lengthInt = (int) length;

String substring = storedClob.getSubString(1,lengthInt);

Common Mistake #5 – Refrain from using clob data type, if the length of the field that should be persisted is less than 4000 chars. Clob, despite being referred in Hibernate documentation that the mapping will be transparent, have some complexities when used with Oracle database. 
	How to Persist , Retrieve clob data type via Hibernate and its Mapping in .hbm.xml:
Clob object = Hibernate.createClob(<replace with ur string field of domain object that carries more than 4000 characters>);
The above code can create a clob object from a string. Though converted to clob Hibernate 3.0 does not persist a clob object properly and hence the string is directly persisted via a String mapping and retrieved via a clob mapping.
Again, Oracle expects the clob to be its last field in the order in which it updates but hibernate merge will place the clob field in middle of insert/update query getting generated . If the length of field following the clob is greater than the clob itself it will result in batch update error BatchUpdateException: ORA-24816. Hence it is better to  perform an explicit update of clob field alone after updating all the fields .
Performance Tuning Tips:
•	If the operations are transaction rich, it is better to avoid using cascade = all in hibernate mapping file for fields.
•	While selecting data from table it is better to use Detached criteria, available in Hibernate.
•	Select-before-update should be made false but this property should be made true in order to enable logging interceptors.
•	Avoid using merge; instead use save,saveOrUpdate, HibernateCallback explicit update with HQl.


Reference(s)
1.http://help.adobe.com/en_US/FlashPlatform/reference/actionscript/3/mx/messaging/channels/StreamingAMFChannel.html